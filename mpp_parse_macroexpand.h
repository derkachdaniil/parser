#pragma once
#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include "lexer.h"
#include <Windows.h>
#include "parser_shared_classes.h"
#include "omni_storage.h"
#include "parser_generator.h"


map<wstring, int> typename_to_size = { {L"auto",1} };

class labels
{
public:
	set<wstring>function_labels;
	set<wstring>if_labels;
	set<wstring>for_labels;
	wstring generate_function_label(wstring name)
	{
		function_labels.insert(name);
		return name;
	}
	wstring generate_if_label(wstring name)
	{
		wstring temp = name + to_wstring(if_labels.size());
		if_labels.insert(temp);
		return temp;
	}
	wstring generate_for_label(wstring name)
	{
		wstring temp = name + to_wstring(for_labels.size());
		for_labels.insert(temp);
		return temp;
	}
};

class parsed_function
{
public:
	wstring name;
	wstring label;
	vector<wstring>parameters_names;
	vector<wstring>parameters_types;
	wstring return_type;
};


class variable
{
public:
	wstring name;
	wstring type;
	int size;
	int shift_from_current_0;
	variable(wstring name_, wstring type_, int shift_from_current_0_)
	{
		name = name_;
		type = type_;
		shift_from_current_0 = shift_from_current_0_;
	}
	variable(wstring name_)
	{
		name = name_;
	}
};
class variables_stack
{
public:
	vector<vector<map<wstring, variable>> > variables;
	int stack_top;
	int stack_current;
	variables_stack()
	{
		variables.push_back(vector<map<wstring, variable>>());
		variables.back().push_back(map<wstring, variable>());
		stack_top = 0;
		stack_current = 0;
	}
	void introduce_function_divider()
	{
		variables.push_back(vector<map<wstring, variable>>());
		variables.back().push_back(map<wstring, variable>());
	}
	void introduce_block_divider()
	{
		variables.back().push_back(map<wstring, variable>());
	}
	void remove_function_divider()
	{
		variables.pop_back();
	}
	void remove_block_divider()
	{
		variables.back().pop_back();
	}
	wstring add_variable(wstring name, wstring type_, bool autogenerated)
	{
		if (autogenerated)
		{
			int sum = 0;
			for (int i = 0; i < variables.back().size(); i++)
				sum += variables.back()[i].size();
			variables.back().back().insert(make_pair(L"gen_" + name + to_wstring(sum), variable(name + to_wstring(sum), type_, stack_top)));
			stack_top += typename_to_size[type_];
			return name + to_wstring(sum);
		}
		else
		{
			variables.back().back().insert(make_pair(L"user_" + name, variable(name, type_, stack_top)));
			stack_top += typename_to_size[type_];
			return name;
		}
	}
	auto find_variable(wstring name, bool autogenerated)
	{
		for (int i = 0; i < variables.back().size(); i++)
			if (autogenerated)
				variables.back()[i].find(L"gen_" + name);
			else
				variables.back()[i].find(L"user_" + name);

	}
	void pop_variable(wstring name, bool autogenerated)
	{
		if (autogenerated)
		{
			if (variables.back().back().find(L"gen_" + name) != variables.back().back().end())
			{
				stack_top -= typename_to_size[variables.back().back().find(L"gen_" + name)->second.type];
				variables.back().back().erase(L"gen_" + name);
			}
		}
		else
			if (variables.back().back().find(L"user_" + name) != variables.back().back().end())
			{
				stack_top -= typename_to_size[variables.back().back().find(L"user_" + name)->second.type];
				variables.back().back().erase(L"user_" + name);
			}

	}
	pair<bool, int> work_with_stack_decider(wstring name)
	{
		for (int i = 0; i < variables.back().size(); i++)
		{
			auto gen = variables.back()[i].find(L"gen_" + name);
			auto user = variables.back()[i].find(L"user_" + name);
			auto res = gen == variables.back()[i].end() ? user : gen;
			if (res == variables.back()[i].end())
				return make_pair(false, 0);
			else
				return make_pair(true, res->second.shift_from_current_0);

		}
	}


};
struct parser_state_apply
{
	vector<vector<wstring>>macroreplaced_program;
	vector< parsed_function>functions;
	labels parsed_labels;
	variables_stack CPP_style_variables;
};
void parser_apply(parser_node* parser)
{
	parser_state_apply st;
	wstring s;
	wstring s2;
	int n;
	s = L"";
	wifstream f2("mpp_parser_test_code.txt");
	while (!f2.eof())
	{
		getline(f2, s2);
		s += s2 + L'\n';
	}
	lexer l2(basic_lexer_rules());
	auto lexemes2 = l2.lex(s);
	omni_storage* omni2 = new oneD_omni_storage(lexemes2);
	n = 0;
	auto temp2 = pick_best(run(parser, omni2, {}));
	//cout << endl << endl;
	//cout << endl << endl;
	//cout << endl << endl;
	//print(temp2);

	skip_skippable(temp2, true);

	//cout << endl << endl;
	//cout << endl << endl;
	//cout << endl << endl;
	//print(temp2);

	simplify(temp2);

	//cout << endl << endl;
	//cout << endl << endl;
	//cout << endl << endl;
	//print(temp2);

	//	vector<unsigned char>return_from_function =
	//	{
	//		address_calculate ,0,source_sector_stack_counter1 + address_target_memory_current1 ,0,
	//		calculate ,memory_,no_changes_first + source_register0 ,target_ret_counter65k + enable_memory_traverse + negative_traverse_direction,
	//		calculate ,memory_,no_changes_first + source_register0 ,target_ret_counter256 + enable_memory_traverse + negative_traverse_direction,
	//		calculate ,memory_,no_changes_first + source_register0 ,target_ret_counter1 + enable_memory_traverse + negative_traverse_direction,
	//		address_calculate ,0,source_ret_counter1 + address_target_program_counter1 ,0,
	//	};

	map<wstring, macros<parser_state_apply>>macroexpander_macroses;
	macroexpander_macroses.insert(make_pair(L"function", macros<parser_state_apply>()));
	macroexpander_macroses[L"function"].add_function(
		[](map<wstring, macros<parser_state_apply>>& macroses, set< parser_node*>& visited, parser_node* cur, parser_state_apply& st)
		{
			wstring temp = ((id_condition*)(cur->conditions[1]))->name;
			st.macroreplaced_program.push_back({ L"label" , st.parsed_labels.generate_function_label(temp) });
			st.functions.push_back(parsed_function());
			st.functions.back().name = temp;
			st.functions.back().label = temp;
			st.functions.back().return_type = ((id_condition*)(cur->conditions[0]))->name;
			for (int i = 2; i < cur->conditions.size() - 2; i += 2)
			{
				st.functions.back().parameters_types.push_back(((id_condition*)(cur->conditions[i]))->name);
				st.functions.back().parameters_names.push_back(((id_condition*)(cur->conditions[i]))->name);
			}
			for (int i = 0; i < cur->conditions.size(); i++)
				cur->conditions[i]->apply_macroses<parser_state_apply>(macroses, st, visited);
			st.macroreplaced_program.push_back({ L"return" });
			return wstring(L"");

		});
	for (int i = 0; i <= 15; i++)
	{
		macroexpander_macroses.insert(make_pair(L"calc-p" + to_wstring(i), macros<parser_state_apply>()));
		macroexpander_macroses[L"calc-p" + to_wstring(i)].add_function(
			[](map<wstring, macros<parser_state_apply>>& macroses, set< parser_node*>& visited, parser_node* cur, parser_state_apply& st)
			{
				if (cur->conditions.size() == 1)
					return cur->conditions[0]->apply_macroses<parser_state_apply>(macroses, st, visited);
				else
				{
					wstring temp = cur->conditions[0]->apply_macroses<parser_state_apply>(macroses, st, visited);
					for (int i = 1; i < cur->conditions.size() - 1; i += 2)
					{
						wstring oper = cur->conditions[i]->apply_macroses<parser_state_apply>(macroses, st, visited);
						wstring temp2 = cur->conditions[i + 1]->apply_macroses<parser_state_apply>(macroses, st, visited);

						auto stack_load = st.CPP_style_variables.work_with_stack_decider(temp2);
						if (stack_load.first == false)
							st.macroreplaced_program.push_back({ L"load",temp2,L"to",L"r1" });
						else
							st.macroreplaced_program.push_back({ L"load",temp2,L"from",L"stack",to_wstring(stack_load.second),L"to",L"r1" });

						stack_load = st.CPP_style_variables.work_with_stack_decider(temp);
						if (stack_load.first == false)
							st.macroreplaced_program.push_back({ L"load",temp,L"to",L"r0" });
						else
							st.macroreplaced_program.push_back({ L"load",temp,L"from",L"stack",to_wstring(stack_load.second),L"to",L"r0" });

						st.CPP_style_variables.pop_variable(temp2, true);
						st.CPP_style_variables.pop_variable(temp, true);

						wstring temp3_name = st.CPP_style_variables.add_variable(L"temp", L"auto", true);
						if (oper == L"")
						{
							cout << 1 << endl;
							oper = cur->conditions[i]->apply_macroses<parser_state_apply>(macroses, st, visited);
						}
						st.macroreplaced_program.push_back({ temp3_name,L"=",L"r0",oper,L"r1" });

						auto stack_save = st.CPP_style_variables.work_with_stack_decider(temp3_name);
						st.macroreplaced_program.push_back({ L"save",temp3_name, L"to",L"stack",to_wstring(stack_save.second) });

						temp = temp3_name;
					}
					return temp;
				}

			});
	}
	apply_macroses<parser_state_apply>(temp2, macroexpander_macroses, st);

	//cout << endl;
	//cout << endl;
	//
	//for (int i = 0; i < st.macroreplaced_program.size(); i++)
	//{
	//
	//	for (int j = 0; j < st.macroreplaced_program[i].size(); j++)
	//		wcout << st.macroreplaced_program[i][j] << ' ';
	//	cout << endl;
	//}
	//
	//cout << endl;
	//cout << endl;
}
void mmp_parser_test()
{
	parser_node* parser = generate_parser(brag_lexer_rules(), basic_lexer_rules(), "mpp_parser.txt");
	parser_apply(parser);
}
